This covers the "Core" Python syntax you need for scripting, automation, and building logic—distinct from the data analysis libraries like Pandas.

pip install -r requirements.txt

### **1. The "Big 4" Data Structures**

Python relies heavily on these four container types. Knowing the difference is 80% of the battle.

| Type | Syntax | Mutable? | Ordered? | Description |
| --- | --- | --- | --- | --- |
| **List** | `x = [1, 2, 3]` | ✅ Yes | ✅ Yes | Standard array. Changeable. |
| **Tuple** | `x = (1, 2, 3)` | ❌ No | ✅ Yes | Read-only list. Faster, safer. |
| **Set** | `x = {1, 2, 3}` | ✅ Yes | ❌ No | Unique values only. Math operations. |
| **Dict** | `x = {'a': 1}` | ✅ Yes | ❌ No | Key-Value pairs. Fast lookups. |

**Common Operations:**

```python
# Lists
my_list = ['a', 'b', 'c']
my_list.append('d')        # Add to end
my_list.pop(0)             # Remove index 0 ('a')
'b' in my_list             # Check existence (True)

# Dictionaries
my_dict = {'name': 'Alex', 'age': 30}
val = my_dict['name']      # Get value (Crash if missing)
val = my_dict.get('job')   # Get value (Returns None if missing - Safe)
my_dict['city'] = 'London' # Add new key

```

---

### **2. String Manipulation & F-Strings**

Python 3.6+ introduced "f-strings", the cleanest way to format text.

```python
name = "Alice"
score = 95.5

# Old Way
print("User " + name + " got " + str(score))

# F-String Way (Do this!)
print(f"User {name} got {score}")

# Formatting Numbers inside F-strings
print(f"Score: {score:.2f}")    # 2 decimal places

```

**Slicing Strings (and Lists):**
Syntax: `[start : stop : step]`

```python
text = "Python"
print(text[0])    # 'P' (First)
print(text[-1])   # 'n' (Last)
print(text[0:2])  # 'Py' (Start at 0, stop BEFORE 2)
print(text[::-1]) # 'nohtyP' (Reverse)

```

---

### **3. Control Flow & Loops**

**If / Elif / Else:**

```python
status = 200

if status == 200:
    print("Success")
elif status == 404:
    print("Not Found")
else:
    print("Unknown Error")

```

**For Loops (The "Pythonic" Way):**
Don't use `i = 0`. Iterate directly over the items.

```python
users = ['Alice', 'Bob', 'Charlie']

# 1. Loop over items
for user in users:
    print(user)

# 2. Loop with Index (Enumerate)
for i, user in enumerate(users):
    print(f"User {i}: {user}")

# 3. Loop a specific number of times
for i in range(5):  # 0 to 4
    print(i)

```

---

### **4. List Comprehensions**

A shorthand way to create lists. You will see this *everywhere* in Python code.

**Syntax:** `[expression for item in list if condition]`

```python
numbers = [1, 2, 3, 4, 5]

# Goal: Get squares of even numbers
# Long way:
squares = []
for n in numbers:
    if n % 2 == 0:
        squares.append(n**2)

# Comprehension way (One line):
squares = [n**2 for n in numbers if n % 2 == 0]

```

---

### **5. Functions**

```python
# Define
def calculate_tax(amount, rate=0.2):  # Default rate is 20%
    """Calculates tax."""             # Docstring
    return amount * rate

# Call
total = calculate_tax(100)            # Uses default 0.2
total = calculate_tax(100, 0.05)      # Overrides default

```

**Lambda Functions (Anonymous):**
Tiny, one-line functions often used inside other functions (like sorting).

```python
# Function that adds 10 to a
add_ten = lambda a: a + 10
print(add_ten(5)) # 15

```

---

### **6. Error Handling (Try / Except)**

Prevent your script from crashing when data is bad.

```python
try:
    result = 10 / 0
except ZeroDivisionError:
    print("You can't divide by zero!")
except Exception as e:
    print(f"Some other error happened: {e}")
finally:
    print("This runs no matter what (cleanup).")

```

---

### **7. File I/O (Context Managers)**

Always use `with open(...)`. It automatically closes the file even if errors occur.

```python
# Writing to a file
with open('log.txt', 'w') as f:
    f.write("Log entry 1\n")

# Reading a file
with open('log.txt', 'r') as f:
    content = f.read()     # Read all
    # lines = f.readlines() # Read into list

```
